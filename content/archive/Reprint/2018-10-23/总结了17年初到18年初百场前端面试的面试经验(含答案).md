---
title: 总结了17年初到18年初百场前端面试的面试经验(含答案)
hidden: true
categories: reprint
slug: 939106f7
date: 2018-10-23 00:00:00
---

{{< raw >}}

                    
<p>我是一名刚毕业的程序媛，面试的岗位是前端开发工程师，从17年初找实习开始，先后面试了50多家公司，加上123面，总共经历了上百场面试，其中包括百度，腾讯，阿里，滴滴，网易，美团等等，也面了一些中小公司的社招。</p>
<p>总结一下面试遇到的问题，希望对大家助，本文很长很长很长（省略n个很长），但是看完的话，确实可以加深前端基础知识的理解，原文链接可以跳转(如果对您有帮助，请帮我点个star，定时更新)：</p>
<p>同时我的博客地址是：<a href="https://github.com/forthealllight/blog" rel="nofollow noreferrer" target="_blank">https://github.com/forthealll...</a> 会定时更新一些学习心得，也欢迎star和fork</p>
<h2 id="articleHeader0"><span style="font-weight:normal;">🌱</span> 文章列表</h2>
<ul>
<li><a href="https://github.com/forthealllight/blog/issues/15" rel="nofollow noreferrer" target="_blank">前端面试总结——基础javascript篇</a></li>
<li><a href="https://github.com/forthealllight/blog/issues/18" rel="nofollow noreferrer" target="_blank">前端面试总结——进阶javascript篇</a></li>
<li><a href="https://github.com/forthealllight/blog/issues/19" rel="nofollow noreferrer" target="_blank">前端面试总结——http、html和浏览器篇</a></li>
<li><a href="https://github.com/forthealllight/blog/issues/20" rel="nofollow noreferrer" target="_blank">前端面试总结——css篇</a></li>
</ul>
<h2 id="articleHeader1">一、基础javascript篇</h2>
<h3 id="articleHeader2">1. get请求传参长度的误区</h3>
<p><strong><em>误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。</em></strong></p>
<p>实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:</p>
<ul>
<li>HTTP 协议 未规定 GET 和POST的长度限制</li>
<li>GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度</li>
<li>不同的浏览器和WEB服务器，限制的最大长度不一样</li>
<li>要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte</li>
</ul>
<h3 id="articleHeader3">2. 补充get和post请求在缓存方面的区别</h3>
<p>post/get的请求区别，具体不再赘述。</p>
<p>补充补充一个get和post在缓存方面的区别：</p>
<ul>
<li>get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。</li>
<li>post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。</li>
</ul>
<h3 id="articleHeader4">3. 闭包</h3>
<p>一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。</p>
<h3 id="articleHeader5">4. 类的创建和继承</h3>
<p>（1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。</p>
<p>下面来创建一个Animal类：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="// 定义一个动物类
function Animal (name) {
  // 属性
  this.name = name || 'Animal';
  // 实例方法
  this.sleep = function(){
    console.log(this.name + '正在睡觉！');
  }
}
// 原型方法
Animal.prototype.eat = function(food) {
  console.log(this.name + '正在吃：' + food);
};
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-comment">// 定义一个动物类</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>{
  <span class="hljs-comment">// 属性</span>
  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Animal'</span>;
  <span class="hljs-comment">// 实例方法</span>
  <span class="hljs-keyword">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">'正在睡觉！'</span>);
  }
}
<span class="hljs-comment">// 原型方法</span>
Animal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">'正在吃：'</span> + food);
};
</code></pre>
<p>这样就生成了一个Animal类，实力化生成对象后，有方法和属性。</p>
<p>（2）类的继承——原型链继承</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="--原型链继承
function Cat(){ }
Cat.prototype = new Animal();
Cat.prototype.name = 'cat';
//　Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.eat('fish'));
console.log(cat.sleep());
console.log(cat instanceof Animal); //true 
console.log(cat instanceof Cat); //true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stata"><code>--原型链继承
function <span class="hljs-keyword">Cat</span>(){ }
<span class="hljs-keyword">Cat</span>.prototype = new Animal();
<span class="hljs-keyword">Cat</span>.prototype.name = '<span class="hljs-keyword">cat</span>';
<span class="hljs-comment">//　Test Code</span>
<span class="hljs-keyword">var</span> <span class="hljs-keyword">cat</span> = new <span class="hljs-keyword">Cat</span>();
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.name);
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.eat('fish'));
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.<span class="hljs-keyword">sleep</span>());
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof Animal); <span class="hljs-comment">//true </span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof <span class="hljs-keyword">Cat</span>); <span class="hljs-comment">//true</span>
</code></pre>
<ul>
<li>介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。</li>
<li>特点：基于原型链，既是父类的实例，也是子类的实例</li>
<li>缺点：无法实现多继承</li>
</ul>
<p>（3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // false
console.log(cat instanceof Cat); // true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>{
  Animal.call(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Tom'</span>;
}
<span class="hljs-comment">// Test Code</span>
<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();
<span class="hljs-built_in">console</span>.log(cat.name);
<span class="hljs-built_in">console</span>.log(cat.sleep());
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">// true</span>
</code></pre>
<ul>
<li>特点：可以实现多继承</li>
<li>缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。</li>
</ul>
<p>（4）实例继承和拷贝继承</p>
<p>实例继承：为父类实例添加新特性，作为子类实例返回</p>
<p>拷贝继承：拷贝父类元素上的属性和方法</p>
<p>上述两个实用性不强，不一一举例。</p>
<p>（5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); // true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stata"><code>function <span class="hljs-keyword">Cat</span>(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
<span class="hljs-keyword">Cat</span>.prototype = new Animal();
<span class="hljs-keyword">Cat</span>.prototype.constructor = <span class="hljs-keyword">Cat</span>;
<span class="hljs-comment">// Test Code</span>
<span class="hljs-keyword">var</span> <span class="hljs-keyword">cat</span> = new <span class="hljs-keyword">Cat</span>();
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.name);
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span>.<span class="hljs-keyword">sleep</span>());
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof Animal); <span class="hljs-comment">// true</span>
console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">cat</span> instanceof <span class="hljs-keyword">Cat</span>); <span class="hljs-comment">// true</span>
</code></pre>
<ul>
<li>特点：可以继承实例属性/方法，也可以继承原型属性/方法</li>
<li>缺点：调用了两次父类构造函数，生成了两份实例</li>
</ul>
<p>（6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
(function(){
  // 创建一个没有实例方法的类
  var Super = function(){};
  Super.prototype = Animal.prototype;
  //将实例作为子类的原型
  Cat.prototype = new Super();
})();
// Test Code
var cat = new Cat();
console.log(cat.name);
console.log(cat.sleep());
console.log(cat instanceof Animal); // true
console.log(cat instanceof Cat); //true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>{
  Animal.call(<span class="hljs-keyword">this</span>);
  <span class="hljs-keyword">this</span>.name = name || <span class="hljs-string">'Tom'</span>;
}
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-comment">// 创建一个没有实例方法的类</span>
  <span class="hljs-keyword">var</span> Super = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{};
  Super.prototype = Animal.prototype;
  <span class="hljs-comment">//将实例作为子类的原型</span>
  Cat.prototype = <span class="hljs-keyword">new</span> Super();
})();
<span class="hljs-comment">// Test Code</span>
<span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat();
<span class="hljs-built_in">console</span>.log(cat.name);
<span class="hljs-built_in">console</span>.log(cat.sleep());
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat); <span class="hljs-comment">//true</span>
</code></pre>
<ul><li>较为推荐</li></ul>
<h3 id="articleHeader6">5. 如何解决异步回调地狱</h3>
<p>promise、generator、async/await</p>
<h3 id="articleHeader7">6. 说说前端中的事件流</h3>
<p>HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。</p>
<p>什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。</p>
<ul>
<li>事件捕获阶段</li>
<li>处于目标阶段</li>
<li>事件冒泡阶段</li>
</ul>
<p><strong>addEventListener</strong>：<strong>addEventListener</strong> 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。</p>
<p><strong>IE只支持事件冒泡</strong>。</p>
<h3 id="articleHeader8">7. 如何让事件先冒泡后捕获</h3>
<p>在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。</p>
<h3 id="articleHeader9">8. 事件委托</h3>
<ul>
<li>简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。</li>
<li>举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。</li>
<li>好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。</li>
</ul>
<h3 id="articleHeader10">9. 图片的懒加载和预加载</h3>
<ul>
<li>预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。</li>
<li>懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。</li>
</ul>
<p>两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br>懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<h3 id="articleHeader11">10. mouseover和mouseenter的区别</h3>
<ul>
<li>mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout</li>
<li>mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave</li>
</ul>
<h3 id="articleHeader12">11. js的new操作符做了哪些事情</h3>
<p>new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。</p>
<h3 id="articleHeader13">12.改变函数内部this指针的指向函数（bind，apply，call的区别）</h3>
<ul>
<li>通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。</li>
<li>通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</li>
</ul>
<h3 id="articleHeader14">13. js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？</h3>
<ul>
<li>clientHeight：表示的是可视区域的高度，不包含border和滚动条</li>
<li>offsetHeight：表示可视区域的高度，包含了border和滚动条</li>
<li>scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。</li>
<li>clientTop：表示边框border的厚度，在未指定的情况下一般为0</li>
<li>scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。</li>
</ul>
<h3 id="articleHeader15">14. js拖拽功能的实现</h3>
<ul><li>首先是三个事件，分别是mousedown，mousemove，mouseup</li></ul>
<p>当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。</p>
<ul>
<li>clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是：<p><strong>鼠标移动时候的坐标-鼠标按下去时候的坐标。</strong></p>
<p>也就是说定位信息为： </p>
<p>鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft.</p>
</li>
<li>还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left<br>   以及top等等值。</li>
</ul>
<p>补充：也可以通过html5的拖放（Drag 和 drop）来实现</p>
<h2 id="articleHeader16">二、进阶javascript篇</h2>
<h3 id="articleHeader17">1.自己实现一个bind函数</h3>
<p><strong><em>原理：通过apply或者call方法来实现。</em></strong></p>
<h4>(1)初始版本</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.prototype.bind=function(obj,arg){
  var arg=Array.prototype.slice.call(arguments,1);
  var context=this;
  return function(newArg){
    arg=arg.concat(Array.prototype.slice.call(newArg));
    return context.apply(obj,arg);
  }
}" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code>Function.prototype.bind=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj,arg){
  <span class="hljs-keyword">var</span> arg=<span class="hljs-keyword">Array</span>.prototype.slice.call(arguments,<span class="hljs-number">1</span>);
  <span class="hljs-keyword">var</span> context=<span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>){
    arg=arg.concat(<span class="hljs-keyword">Array</span>.prototype.slice.call(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>));
    <span class="hljs-keyword">return</span> context.apply(obj,arg);
  }
}</code></pre>
<h4>(2) 考虑到原型链</h4>
<p><strong><em>为什么要考虑？因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型</em></strong></p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.prototype.bind=function(obj,arg){
  var arg=Array.prototype.slice.call(arguments,1);
  var context=this;
  var bound=function(newArg){
    arg=arg.concat(Array.prototype.slice.call(newArg));
    return context.apply(obj,arg);
  }
  var F=function(){}
  //这里需要一个寄生组合继承
  F.prototype=context.prototype;
  bound.prototype=new F();
  return bound;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code>Function.prototype.bind=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(obj,arg){
  <span class="hljs-keyword">var</span> arg=<span class="hljs-keyword">Array</span>.prototype.slice.call(arguments,<span class="hljs-number">1</span>);
  <span class="hljs-keyword">var</span> context=<span class="hljs-built_in">this</span>;
  <span class="hljs-keyword">var</span> bound=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>){
    arg=arg.concat(<span class="hljs-keyword">Array</span>.prototype.slice.call(<span class="hljs-keyword">new</span><span class="hljs-type">Arg</span>));
    <span class="hljs-keyword">return</span> context.apply(obj,arg);
  }
  <span class="hljs-keyword">var</span> F=<span class="hljs-function"><span class="hljs-keyword">function</span></span>(){}
  <span class="hljs-comment">//这里需要一个寄生组合继承</span>
  F.prototype=context.prototype;
  bound.prototype=<span class="hljs-keyword">new</span> <span class="hljs-type">F</span>();
  <span class="hljs-keyword">return</span> bound;
}
</code></pre>
<h3 id="articleHeader18">2.用setTimeout来实现setInterval</h3>
<h4>(1)用setTimeout()方法来模拟setInterval()与setInterval()之间的什么区别？</h4>
<p>首先来看setInterval的缺陷，使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的是：javascript引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。</p>
<p>这种重复定时器的规则有两个问题：<strong><em>1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。</em></strong></p>
<p>下面举例子说明： </p>
<p>假设，某个onclick事件处理程序使用啦setInterval()来设置了一个200ms的重复定时器。如果事件处理程序花了300ms多一点的时间完成。</p>
<p>&lt;img width="626" alt="2018-07-10 11 36 43" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648412f2eb805ec?w=1252&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=498&amp;f=png&amp;s=326047"&gt;</p>
<p>这个例子中的第一个定时器是在205ms处添加到队列中，但是要过300ms才能执行。在405ms又添加了一个副本。在一个间隔，605ms处，第一个定时器代码还在执行中，而且队列中已经有了一个定时器实例，结果是605ms的定时器代码不会添加到队列中。结果是在5ms处添加的定时器代码执行结束后，405处的代码立即执行。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function say(){
  //something
  setTimeout(say,200);
}
setTimeout(say,200)
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs actionscript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span>{
  <span class="hljs-comment">//something</span>
  setTimeout(say,<span class="hljs-number">200</span>);
}
setTimeout(say,<span class="hljs-number">200</span>)
</code></pre>
<p>或者</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="setTimeout(function(){
   //do something
   setTimeout(arguments.callee,200);
},200);
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-comment">//do something</span>
   setTimeout(<span class="hljs-built_in">arguments</span>.callee,<span class="hljs-number">200</span>);
},<span class="hljs-number">200</span>);
</code></pre>
<h3 id="articleHeader19">3.js怎么控制一次加载一张图片，加载完后再加载下一张</h3>
<h4>(1)方法1</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<script type=&quot;text/javascript&quot;>
var obj=new Image();
obj.src=&quot;http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg&quot;;
obj.onload=function(){
alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);
document.getElementById(&quot;mypic&quot;).innnerHTML=&quot;<img src='&quot;+this.src+&quot;' />&quot;;
}
</script>
<div id=&quot;mypic&quot;>onloading……</div>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Image();
obj.src=<span class="hljs-string">"http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg"</span>;
obj.onload=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
alert(<span class="hljs-string">'图片的宽度为：'</span>+obj.width+<span class="hljs-string">'；图片的高度为：'</span>+obj.height);
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mypic"</span>).innnerHTML=<span class="hljs-string">"&lt;img src='"</span>+<span class="hljs-keyword">this</span>.src+<span class="hljs-string">"' /&gt;"</span>;
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mypic"</span>&gt;</span>onloading……<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h4>(2)方法2</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<script type=&quot;text/javascript&quot;>
var obj=new Image();
obj.src=&quot;http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg&quot;;
obj.onreadystatechange=function(){
if(this.readyState==&quot;complete&quot;){
alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height);
document.getElementById(&quot;mypic&quot;).innnerHTML=&quot;<img src='&quot;+this.src+&quot;' />&quot;;
}
}
</script>
<div id=&quot;mypic&quot;>onloading……</div>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">var</span> obj=<span class="hljs-keyword">new</span> Image();
obj.src=<span class="hljs-string">"http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg"</span>;
obj.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
<span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.readyState==<span class="hljs-string">"complete"</span>){
alert(<span class="hljs-string">'图片的宽度为：'</span>+obj.width+<span class="hljs-string">'；图片的高度为：'</span>+obj.height);
<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"mypic"</span>).innnerHTML=<span class="hljs-string">"&lt;img src='"</span>+<span class="hljs-keyword">this</span>.src+<span class="hljs-string">"' /&gt;"</span>;
}
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"mypic"</span>&gt;</span>onloading……<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<h3 id="articleHeader20">3.代码的执行顺序</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="setTimeout(function(){console.log(1)},0);
new Promise(function(resolve,reject){
   console.log(2);
   resolve();
}).then(function(){console.log(3)
}).then(function(){console.log(4)});

process.nextTick(function(){console.log(5)});

console.log(6);
//输出2,6,5,3,4,1
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)},<span class="hljs-number">0</span>);
<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>{
   <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);
   resolve();
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)
}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>)});

process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>)});

<span class="hljs-built_in">console</span>.log(<span class="hljs-number">6</span>);
<span class="hljs-comment">//输出2,6,5,3,4,1</span>
</code></pre>
<p>为什么呢？具体请参考我的文章：[<br>从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue](<a href="https://github.com/forthealllight/blog/issues/5)" rel="nofollow noreferrer" target="_blank">https://github.com/forthealll...</a></p>
<h3 id="articleHeader21">4.如何实现sleep的效果（es5或者es6）</h3>
<h4>(1)while循环的方式</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){
   var start=Date.now(),expire=start+ms;
   while(Date.now()<expire);
   console.log('1111');
   return;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{
   <span class="hljs-keyword">var</span> start=<span class="hljs-built_in">Date</span>.now(),expire=start+ms;
   <span class="hljs-keyword">while</span>(<span class="hljs-built_in">Date</span>.now()&lt;expire);
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'1111'</span>);
   <span class="hljs-keyword">return</span>;
}
</code></pre>
<p>执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。</p>
<h3 id="articleHeader22">(2)通过promise来实现</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){
  var temple=new Promise(
  (resolve)=>{
  console.log(111);setTimeout(resolve,ms)
  });
  return temple
}
sleep(500).then(function(){
   //console.log(222)
})
//先输出了111，延迟500ms后输出222
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{
  <span class="hljs-keyword">var</span> temple=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(
  <span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);setTimeout(resolve,ms)
  });
  <span class="hljs-keyword">return</span> temple
}
sleep(<span class="hljs-number">500</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
   <span class="hljs-comment">//console.log(222)</span>
})
<span class="hljs-comment">//先输出了111，延迟500ms后输出222</span>
</code></pre>
<h3 id="articleHeader23">(3)通过async封装</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function sleep(ms){
  return new Promise((resolve)=>setTimeout(resolve,ms));
}
async function test(){
  var temple=await sleep(1000);
  console.log(1111)
  return temple
}
test();
//延迟1000ms输出了1111
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>)=&gt;</span>setTimeout(resolve,ms));
}
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">var</span> temple=<span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>);
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1111</span>)
  <span class="hljs-keyword">return</span> temple
}
test();
<span class="hljs-comment">//延迟1000ms输出了1111</span>
</code></pre>
<h4>(4).通过generate来实现</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function* sleep(ms){
   yield new Promise(function(resolve,reject){
             console.log(111);
             setTimeout(resolve,ms);
        })  
}
sleep(500).next().value.then(function(){console.log(2222)})

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>)</span>{
   <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)</span>{
             <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);
             setTimeout(resolve,ms);
        })  
}
sleep(<span class="hljs-number">500</span>).next().value.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2222</span>)})

</code></pre>
<h3 id="articleHeader24">5.简单的实现一个promise</h3>
<p>首先明确什么是promiseA+规范，参考规范的地址：</p>
<p><a href="https://promisesaplus.com/" rel="nofollow noreferrer" target="_blank">primiseA+规范</a></p>
<p>如何实现一个promise，参考我的文章：</p>
<p><a href="https://github.com/forthealllight/blog/issues/4" rel="nofollow noreferrer" target="_blank">实现一个完美符合Promise/A+规范的Promise</a></p>
<p>一般不会问的很详细，只要能写出上述文章中的v1.0版本的简单promise即可。</p>
<h3 id="articleHeader25">6.Function.__proto__(getPrototypeOf)是什么？</h3>
<p>获取一个对象的原型，在chrome中可以通过__proto__的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。</p>
<p>那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Function.__proto__==Object.prototype //false
Function.__proto__==Function.prototype//true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs monkey"><code><span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">__proto__</span>=</span>=Object.prototype //<span class="hljs-literal">false</span>
<span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">__proto__</span>=</span>=<span class="hljs-function"><span class="hljs-keyword">Function</span>.<span class="hljs-title">prototype</span>//<span class="hljs-title">true</span></span>
</code></pre>
<p>我们发现Function的原型也是Function。</p>
<p>我们用图可以来明确这个关系：</p>
<p>&lt;img width="646" alt="2018-07-10 2 38 27" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648412f2ed72c1d?w=1292&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=1028&amp;f=png&amp;s=183106"&gt;</p>
<h3 id="articleHeader26">7.实现js中所有对象的深度克隆（包装对象，Date对象，正则对象）</h3>
<p>通过递归可以简单实现对象的深度克隆，但是这种方法不管是ES6还是ES5实现，都有同样的缺陷，就是只能实现特定的object的深度复制（比如数组和函数），不能实现包装对象Number，String ， Boolean，以及Date对象，RegExp对象的复制。</p>
<h4>(1)前文的方法</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function deepClone(obj){
    var newObj= obj instanceof Array?[]:{};
    for(var i in obj){
       newObj[i]=typeof obj[i]=='object'?  
       deepClone(obj[i]):obj[i];    
    }
    return newObj;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span></span>(obj){
    <span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>= obj instanceof <span class="hljs-keyword">Array</span>?[]:<span class="hljs-type"></span>{};
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj){
       <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>[i]=typeof obj[i]==<span class="hljs-string">'object'</span>?  
       deepClone(obj[i]):<span class="hljs-type">obj</span>[i];    
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>;
}
</code></pre>
<p>这种方法可以实现一般对象和数组对象的克隆，比如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var arr=[1,2,3];
var newArr=deepClone(arr);
// newArr->[1,2,3]

var obj={
   x:1,
   y:2
}
var newObj=deepClone(obj);
// newObj={x:1,y:2}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-keyword">var</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];
<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Arr</span>=deepClone(arr);
<span class="hljs-comment">// newArr-&gt;[1,2,3]</span>

<span class="hljs-keyword">var</span> obj={
   x:<span class="hljs-type">1</span>,
   y:<span class="hljs-type">2</span>
}
<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Obj</span>=deepClone(obj);
<span class="hljs-comment">// newObj={x:1,y:2}</span>
</code></pre>
<p>但是不能实现例如包装对象Number,String,Boolean,以及正则对象RegExp和Date对象的克隆，比如：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="//Number包装对象
var num=new Number(1);
typeof num // &quot;object&quot;

var newNum=deepClone(num);
//newNum ->  {} 空对象

//String包装对象
var str=new String(&quot;hello&quot;);
typeof str //&quot;object&quot;

var newStr=deepClone(str);
//newStr->  {0:'h',1:'e',2:'l',3:'l',4:'o'};

//Boolean包装对象
var bol=new Boolean(true);
typeof bol //&quot;object&quot;

var newBol=deepClone(bol);
// newBol ->{} 空对象

....
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-comment">//Number包装对象</span>
<span class="hljs-keyword">var</span> num=<span class="hljs-keyword">new</span> <span class="hljs-type">Number</span>(<span class="hljs-number">1</span>);
typeof num <span class="hljs-comment">// "object"</span>

<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Num</span>=deepClone(num);
<span class="hljs-comment">//newNum -&gt;  {} 空对象</span>

<span class="hljs-comment">//String包装对象</span>
<span class="hljs-keyword">var</span> str=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">"hello"</span>);
typeof str <span class="hljs-comment">//"object"</span>

<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>=deepClone(str);
<span class="hljs-comment">//newStr-&gt;  {0:'h',1:'e',2:'l',3:'l',4:'o'};</span>

<span class="hljs-comment">//Boolean包装对象</span>
<span class="hljs-keyword">var</span> bol=<span class="hljs-keyword">new</span> <span class="hljs-type">Boolean</span>(<span class="hljs-literal">true</span>);
typeof bol <span class="hljs-comment">//"object"</span>

<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Bol</span>=deepClone(bol);
<span class="hljs-comment">// newBol -&gt;{} 空对象</span>

....
</code></pre>
<h4>(2)valueof()函数</h4>
<p>所有对象都有valueOf方法，valueOf方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回这个对象本身。</p>
<p>对于原始值或者包装类：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function baseClone(base){
 return base.valueOf();
}

//Number
var num=new Number(1);
var newNum=baseClone(num);
//newNum->1

//String
var str=new String('hello');
var newStr=baseClone(str);
// newStr->&quot;hello&quot;

//Boolean
var bol=new Boolean(true);
var newBol=baseClone(bol);
//newBol-> true
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haxe"><code><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseClone</span></span>(base){
 <span class="hljs-keyword">return</span> base.valueOf();
}

<span class="hljs-comment">//Number</span>
<span class="hljs-keyword">var</span> num=<span class="hljs-keyword">new</span> <span class="hljs-type">Number</span>(<span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Num</span>=baseClone(num);
<span class="hljs-comment">//newNum-&gt;1</span>

<span class="hljs-comment">//String</span>
<span class="hljs-keyword">var</span> str=<span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(<span class="hljs-string">'hello'</span>);
<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>=baseClone(str);
<span class="hljs-comment">// newStr-&gt;"hello"</span>

<span class="hljs-comment">//Boolean</span>
<span class="hljs-keyword">var</span> bol=<span class="hljs-keyword">new</span> <span class="hljs-type">Boolean</span>(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Bol</span>=baseClone(bol);
<span class="hljs-comment">//newBol-&gt; true</span>
</code></pre>
<p>其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说，</p>
<p>这里用valueOf实现，语法上比较符合规范。</p>
<p>对于Date类型：</p>
<p>因为valueOf方法，日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数.因此我们可以在Date的原型上定义克隆的方法：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Date.prototype.clone=function(){
  return new Date(this.valueOf());
}

var date=new Date('2010');
var newDate=date.clone();
// newDate->  Fri Jan 01 2010 08:00:00 GMT+0800 
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs qml"><code><span class="hljs-built_in">Date</span>.prototype.clone=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-keyword">this</span>.valueOf());
}

<span class="hljs-built_in">var</span> <span class="hljs-built_in">date</span>=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">'2010'</span>);
<span class="hljs-built_in">var</span> newDate=<span class="hljs-built_in">date</span>.clone();
<span class="hljs-comment">// newDate-&gt;  Fri Jan 01 2010 08:00:00 GMT+0800 </span>
</code></pre>
<p>对于正则对象RegExp：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="RegExp.prototype.clone = function() {
var pattern = this.valueOf();
var flags = '';
flags += pattern.global ? 'g' : '';
flags += pattern.ignoreCase ? 'i' : '';
flags += pattern.multiline ? 'm' : '';
return new RegExp(pattern.source, flags);
};

var reg=new RegExp('/111/');
var newReg=reg.clone();
//newReg->  /\/111\//
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-built_in">RegExp</span>.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
<span class="hljs-keyword">var</span> pattern = <span class="hljs-keyword">this</span>.valueOf();
<span class="hljs-keyword">var</span> flags = <span class="hljs-string">''</span>;
flags += pattern.global ? <span class="hljs-string">'g'</span> : <span class="hljs-string">''</span>;
flags += pattern.ignoreCase ? <span class="hljs-string">'i'</span> : <span class="hljs-string">''</span>;
flags += pattern.multiline ? <span class="hljs-string">'m'</span> : <span class="hljs-string">''</span>;
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(pattern.source, flags);
};

<span class="hljs-keyword">var</span> reg=<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'/111/'</span>);
<span class="hljs-keyword">var</span> newReg=reg.clone();
<span class="hljs-comment">//newReg-&gt;  /\/111\//</span>
</code></pre>
<h3 id="articleHeader27">8.简单实现Node的Events模块</h3>
<p>简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。</p>
<p>node中的Events模块就是通过观察者模式来实现的：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var events=require('events');
var eventEmitter=new events.EventEmitter();
eventEmitter.on('say',function(name){
    console.log('Hello',name);
})
eventEmitter.emit('say','Jony yu');
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> events=<span class="hljs-built_in">require</span>(<span class="hljs-string">'events'</span>);
<span class="hljs-keyword">var</span> eventEmitter=<span class="hljs-keyword">new</span> events.EventEmitter();
eventEmitter.on(<span class="hljs-string">'say'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>,name);
})
eventEmitter.emit(<span class="hljs-string">'say'</span>,<span class="hljs-string">'Jony yu'</span>);
</code></pre>
<p>这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。</p>
<h4>(1)实现简单的Event模块的emit和on方法</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="function Events(){
this.on=function(eventName,callBack){
  if(!this.handles){
    this.handles={};
  }
  if(!this.handles[eventName]){
    this.handles[eventName]=[];
  }
  this.handles[eventName].push(callBack);
}
this.emit=function(eventName,obj){
   if(this.handles[eventName]){
     for(var i=0;o<this.handles[eventName].length;i++){
       this.handles[eventName][i](obj);
     }
   }
}
return this;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>function Events(){
<span class="hljs-keyword">this</span>.on=function(eventName,callBack){
  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.handles){
    <span class="hljs-keyword">this</span>.handles={};
  }
  <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">this</span>.handles[eventName]){
    <span class="hljs-keyword">this</span>.handles[eventName]=[];
  }
  <span class="hljs-keyword">this</span>.handles[eventName].push(callBack);
}
<span class="hljs-keyword">this</span>.emit=function(eventName,obj){
   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.handles[eventName]){
     <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;o&lt;<span class="hljs-keyword">this</span>.handles[eventName].length;i++){
       <span class="hljs-keyword">this</span>.handles[eventName][i](obj);
     }
   }
}
<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
}
</code></pre>
<p>这样我们就定义了Events，现在我们可以开始来调用：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" var events=new Events();
 events.on('say',function(name){
    console.log('Hello',nama)
 });
 events.emit('say','Jony yu');
 //结果就是通过emit调用之后，输出了Jony yu
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code> <span class="hljs-keyword">var</span> events=<span class="hljs-keyword">new</span> Events();
 events.on(<span class="hljs-string">'say'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>,nama)
 });
 events.emit(<span class="hljs-string">'say'</span>,<span class="hljs-string">'Jony yu'</span>);
 <span class="hljs-comment">//结果就是通过emit调用之后，输出了Jony yu</span>
</code></pre>
<h4>(2)每个对象是独立的</h4>
<p>因为是通过new的方式，每次生成的对象都是不相同的，因此：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var event1=new Events();
var event2=new Events();
event1.on('say',function(){
    console.log('Jony event1');
});
event2.on('say',function(){
    console.log('Jony event2');
})
event1.emit('say');
event2.emit('say');
//event1、event2之间的事件监听互相不影响
//输出结果为'Jony event1' 'Jony event2'
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> event1=<span class="hljs-keyword">new</span> Events();
<span class="hljs-keyword">var</span> event2=<span class="hljs-keyword">new</span> Events();
event1.on(<span class="hljs-string">'say'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Jony event1'</span>);
});
event2.on(<span class="hljs-string">'say'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Jony event2'</span>);
})
event1.emit(<span class="hljs-string">'say'</span>);
event2.emit(<span class="hljs-string">'say'</span>);
<span class="hljs-comment">//event1、event2之间的事件监听互相不影响</span>
<span class="hljs-comment">//输出结果为'Jony event1' 'Jony event2'</span>
</code></pre>
<h3 id="articleHeader28">9.箭头函数中this指向举例</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="var a=11;
function test2(){
  this.a=22;
  let b=()=>{console.log(this.a)}
  b();
}
var x=new test2();
//输出22
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs javascript"><code><span class="hljs-keyword">var</span> a=<span class="hljs-number">11</span>;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test2</span>(<span class="hljs-params"></span>)</span>{
  <span class="hljs-keyword">this</span>.a=<span class="hljs-number">22</span>;
  <span class="hljs-keyword">let</span> b=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>{<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.a)}
  b();
}
<span class="hljs-keyword">var</span> x=<span class="hljs-keyword">new</span> test2();
<span class="hljs-comment">//输出22</span>
</code></pre>
<p>定义时绑定。</p>
<h2 id="articleHeader29">三、http、html和浏览器篇</h2>
<h3 id="articleHeader30">1.http和https</h3>
<p><strong><em>https的SSL加密是在传输层实现的。</em></strong></p>
<h4>(1)http和https的基本概念</h4>
<p>http: 超文本传输协议，是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端请求和应答的标准（TCP），用于从WWW服务器传输超文本到本地浏览器的传输协议，它可以使浏览器更加高效，使网络传输减少。</p>
<p>https: 是以安全为目标的HTTP通道，简单讲是HTTP的安全版，即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p>https协议的主要作用是：建立一个信息安全通道，来确保数组的传输，确保网站的真实性。</p>
<h4>(2)http和https的区别？</h4>
<p>http传输的数据都是未加密的，也就是明文的，网景公司设置了SSL协议来对http协议传输的数据进行加密处理，简单来说https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。<br>主要的区别如下：</p>
<ul>
<li>Https协议需要ca证书，费用较高。</li>
<li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li>
<li>使用不同的链接方式，端口也不同，一般而言，http协议的端口为80，https的端口为443</li>
<li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li>
</ul>
<h4>(3)https协议的工作原理</h4>
<p>客户端在使用HTTPS方式与Web服务器通信时有以下几个步骤，如图所示。</p>
<ul>
<li>客户使用https url访问服务器，则要求web 服务器建立ssl链接。</li>
<li>web服务器接收到客户端的请求之后，会将网站的证书（证书中包含了公钥），返回或者说传输给客户端。</li>
<li>客户端和web服务器端开始协商SSL链接的安全等级，也就是加密等级。</li>
<li>客户端浏览器通过双方协商一致的安全等级，建立会话密钥，然后通过网站的公钥来加密会话密钥，并传送给网站。</li>
<li>web服务器通过自己的私钥解密出会话密钥。</li>
<li>web服务器通过会话密钥加密与客户端之间的通信。</li>
</ul>
<h4>(4)https协议的优点</h4>
<ul>
<li>使用HTTPS协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</li>
<li>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性。</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</li>
<li>谷歌曾在2014年8月份调整搜索引擎算法，并称“比起同等HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高”。</li>
</ul>
<h4>(5)https协议的缺点</h4>
<ul>
<li>https握手阶段比较费时，会使页面加载时间延长50%，增加10%~20%的耗电。</li>
<li>https缓存不如http高效，会增加数据开销。</li>
<li>SSL证书也需要钱，功能越强大的证书费用越高。</li>
<li>SSL证书需要绑定IP，不能再同一个ip上绑定多个域名，ipv4资源支持不了这种消耗。</li>
</ul>
<h3 id="articleHeader31">2.tcp三次握手，一句话概括</h3>
<p><strong><em>客户端和服务端都需要直到各自可收发，因此需要三次握手。</em></strong></p>
<p>简化三次握手：</p>
<p>&lt;img width="487" alt="2018-07-10 3 42 11" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/16484133eee33c76?w=974&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=1038&amp;f=png&amp;s=94703"&gt;</p>
<p>从图片可以得到三次握手可以简化为：C发起请求连接S确认，也发起连接C确认我们再看看每次握手的作用：第一次握手：S只可以确认 自己可以接受C发送的报文段第二次握手：C可以确认 S收到了自己发送的报文段，并且可以确认 自己可以接受S发送的报文段第三次握手：S可以确认 C收到了自己发送的报文段</p>
<h3 id="articleHeader32">3.TCP和UDP的区别</h3>
<p>（1）TCP是面向连接的，udp是无连接的即发送数据前不需要先建立链接。</p>
<p>（2）TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。 并且因为tcp可靠，面向连接，不会丢失数据因此适合大数据量的交换。</p>
<p>（3）TCP是面向字节流，UDP面向报文，并且网络出现拥塞不会使得发送速率降低（因此会出现丢包，对实时的应用比如IP电话和视频会议等）。</p>
<p>（4）TCP只能是1对1的，UDP支持1对1,1对多。</p>
<p>（5）TCP的首部较大为20字节，而UDP只有8字节。</p>
<p>（6）TCP是面向连接的可靠性传输，而UDP是不可靠的。</p>
<h3 id="articleHeader33">4.WebSocket的实现和应用</h3>
<h4>(1)什么是WebSocket?</h4>
<p>WebSocket是HTML5中的协议，支持持久连续，http协议不支持持久性连接。Http1.0和HTTP1.1都不支持持久性的链接，HTTP1.1中的keep-alive，将多个http请求合并为1个</p>
<h4>(2)WebSocket是什么样的协议，具体有什么优点？</h4>
<ul>
<li>HTTP的生命周期通过Request来界定，也就是Request一个Response，那么在Http1.0协议中，这次Http请求就结束了。在Http1.1中进行了改进，是的有一个connection：Keep-alive，也就是说，在一个Http连接中，可以发送多个Request，接收多个Response。但是必须记住，在Http中一个Request只能对应有一个Response，而且这个Response是被动的，不能主动发起。</li>
<li>WebSocket是基于Http协议的，或者说借用了Http协议来完成一部分握手，在握手阶段与Http是相同的。我们来看一个websocket握手协议的实现，基本是2个属性，upgrade，connection。</li>
</ul>
<p>基本请求如下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs http"><code><span class="hljs-keyword">GET</span> <span class="hljs-string">/chat</span> HTTP/1.1
<span class="hljs-attribute">Host</span>: server.example.com
<span class="hljs-attribute">Upgrade</span>: websocket
<span class="hljs-attribute">Connection</span>: Upgrade
<span class="hljs-attribute">Sec-WebSocket-Key</span>: x3JJHMbDL1EzLkh9GBhXDw==
<span class="hljs-attribute">Sec-WebSocket-Protocol</span>: chat, superchat
<span class="hljs-attribute">Sec-WebSocket-Version</span>: 13
<span class="hljs-attribute">Origin</span>: http://example.com
</code></pre>
<p>多了下面2个属性：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="Upgrade:webSocket
Connection:Upgrade
告诉服务器发送的是websocket
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs avrasm"><code><span class="hljs-symbol">Upgrade:</span>webSocket
<span class="hljs-symbol">Connection:</span>Upgrade
告诉服务器发送的是websocket
<span class="hljs-keyword">Sec</span>-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
<span class="hljs-keyword">Sec</span>-WebSocket-Protocol: chat, superchat
<span class="hljs-keyword">Sec</span>-WebSocket-Version: <span class="hljs-number">13</span>
</code></pre>
<h3 id="articleHeader34">5.HTTP请求的方式，HEAD方式</h3>
<ul>
<li>head：类似于get请求，只不过返回的响应中没有具体的内容，用户获取报头</li>
<li>options：允许客户端查看服务器的性能，比如说服务器支持的请求方式等等。</li>
</ul>
<h3 id="articleHeader35">6.一个图片url访问后直接下载怎样实现？</h3>
<p>请求的返回头里面，用于浏览器解析的重要参数就是OSS的API文档里面的返回http头，决定用户下载行为的参数。</p>
<p>下载的情况下：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="  1. x-oss-object-type:
         Normal
  2. x-oss-request-id:
         598D5ED34F29D01FE2925F41
  3. x-oss-storage-class:
         Standard
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs kotlin"><code>  <span class="hljs-number">1.</span> x-oss-<span class="hljs-keyword">object</span>-type:
         Normal
  <span class="hljs-number">2.</span> x-oss-request-id:
         <span class="hljs-number">598</span>D5ED34F29D01FE2925F41
  <span class="hljs-number">3.</span> x-oss-storage-<span class="hljs-class"><span class="hljs-keyword">class</span>:
         <span class="hljs-type">Standard</span></span>
</code></pre>
<h3 id="articleHeader36">7.web Quality （无障碍）</h3>
<p>能够被残障人士使用的网站才能称得上一个易用的（易访问的）网站。<br>残障人士指的是那些带有残疾或者身体不健康的用户。</p>
<p>使用alt属性：</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<img src=&quot;person.jpg&quot;  alt=&quot;this is a person&quot;/>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs stylus"><code>&lt;<span class="hljs-selector-tag">img</span> src=<span class="hljs-string">"person.jpg"</span>  alt=<span class="hljs-string">"this is a person"</span>/&gt;
</code></pre>
<p>有时候浏览器会无法显示图像。具体的原因有：</p>
<ul>
<li>用户关闭了图像显示</li>
<li>浏览器是不支持图形显示的迷你浏览器</li>
<li>浏览器是语音浏览器（供盲人和弱视人群使用）</li>
</ul>
<p>如果您使用了 alt 属性，那么浏览器至少可以显示或读出有关图像的描述。</p>
<h3 id="articleHeader37">8.几个很实用的BOM属性对象方法?</h3>
<p>什么是Bom? Bom是浏览器对象。有哪些常用的Bom属性呢？</p>
<h4>(1)location对象</h4>
<p>location.href-- 返回或设置当前文档的URL<br>location.search -- 返回URL中的查询字符串部分。例如 <a href="http://www.dreamdu.com/dreamdu.php?id=5&amp;name=dreamdu" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com/dreamd...</a> 返回包括(?)后面的内容?id=5&amp;name=dreamdu<br>location.hash -- 返回URL#后面的内容，如果没有#，返回空<br>location.host -- 返回URL中的域名部分，例如www.dreamdu.com<br>location.hostname -- 返回URL中的主域名部分，例如dreamdu.com<br>location.pathname -- 返回URL的域名后的部分。例如 <a href="http://www.dreamdu.com/xhtml/" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com/xhtml/</a> 返回/xhtml/<br>location.port -- 返回URL中的端口部分。例如 <a href="http://www.dreamdu.com" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com</a>:8080/xhtml/ 返回8080<br>location.protocol -- 返回URL中的协议部分。例如 <a href="http://www.dreamdu.com" rel="nofollow noreferrer" target="_blank">http://www.dreamdu.com</a>:8080/xhtml/ 返回(//)前面的内容http:<br>location.assign -- 设置当前文档的URL<br>location.replace() -- 设置当前文档的URL，并且在history对象的地址列表中移除这个URL location.replace(url);<br>location.reload() -- 重载当前页面</p>
<h4>(2)history对象</h4>
<p>history.go() -- 前进或后退指定的页面数 history.go(num);<br>history.back() -- 后退一页<br>history.forward() -- 前进一页</p>
<h4>(3)Navigator对象</h4>
<p>navigator.userAgent -- 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串)<br>navigator.cookieEnabled -- 返回浏览器是否支持(启用)cookie</p>
<h3 id="articleHeader38">9.HTML5  drag api</h3>
<ul>
<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发，。</li>
<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li>
<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li>
<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li>
<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li>
<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li>
<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发</li>
</ul>
<h3 id="articleHeader39">10.http2.0</h3>
<p>首先补充一下，http和https的区别，相比于http,https是基于ssl加密的http协议<br>简要概括：http2.0是基于1999年发布的http1.0之后的首次更新。</p>
<ul>
<li>提升访问速度（可以对于，请求资源所需时间更少，访问速度更快，相比http1.0）</li>
<li>允许多路复用：多路复用允许同时通过单一的HTTP/2连接发送多重请求-响应信息。改善了：在http1.1中，浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制（连接数量），超过限制会被阻塞。</li>
<li>二进制分帧：HTTP2.0会将所有的传输信息分割为更小的信息或者帧，并对他们进行二进制编码</li>
<li>首部压缩</li>
<li>服务器端推送</li>
</ul>
<h3 id="articleHeader40">11.补充400和401、403状态码</h3>
<h4>(1)400状态码：请求无效</h4>
<p>产生原因：</p>
<ul>
<li>前端提交数据的字段名称和字段类型与后台的实体没有保持一致</li>
<li>前端提交到后台的数据应该是json字符串类型，但是前端没有将对象JSON.stringify转化成字符串。</li>
</ul>
<p>解决方法：</p>
<ul>
<li>对照字段的名称，保持一致性</li>
<li>将obj对象通过JSON.stringify实现序列化</li>
</ul>
<h4>(2)401状态码：当前请求需要用户验证</h4>
<h4>(3)403状态码：服务器已经得到请求，但是拒绝执行</h4>
<h3 id="articleHeader41">12.fetch发送2次请求的原因</h3>
<p><strong><em>fetch发送post请求的时候，总是发送2次，第一次状态码是204，第二次才成功？</em></strong></p>
<p>原因很简单，因为你用fetch的post请求的时候，导致fetch 第一次发送了一个Options请求，询问服务器是否支持修改的请求头，如果服务器支持，则在第二次中发送真正的请求。</p>
<h3 id="articleHeader42">13.Cookie、sessionStorage、localStorage的区别</h3>
<p>共同点：都是保存在浏览器端，并且是同源的</p>
<ul>
<li>Cookie：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下,存储的大小很小只有4K左右。 （key：可以在浏览器和服务器端来回传递，存储容量小，只有大约4K左右）</li>
<li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。（key：本身就是一个回话过程，关闭浏览器后消失，session为一个回话，当页面不同即使是同一页面打开两次，也被视为同一次回话）</li>
<li>localStorage：localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。（key：同源窗口都会共享，并且不会失效，不管窗口或者浏览器关闭与否都会始终生效）</li>
</ul>
<p>补充说明一下cookie的作用：</p>
<ul>
<li>保存用户登录状态。例如将用户id存储于一个cookie内，这样当用户下次访问该页面时就不需要重新登录了，现在很多论坛和社区都提供这样的功能。 cookie还可以设置过期时间，当超过时间期限后，cookie就会自动消失。因此，系统往往可以提示用户保持登录状态的时间：常见选项有一个月、三个 月、一年等。</li>
<li>跟踪用户行为。例如一个天气预报网站，能够根据用户选择的地区显示当地的天气情况。如果每次都需要选择所在地是烦琐的，当利用了 cookie后就会显得很人性化了，系统能够记住上一次访问的地区，当下次再打开该页面时，它就会自动显示上次用户所在地区的天气情况。因为一切都是在后 台完成，所以这样的页面就像为某个用户所定制的一样，使用起来非常方便</li>
<li>定制页面。如果网站提供了换肤或更换布局的功能，那么可以使用cookie来记录用户的选项，例如：背景色、分辨率等。当用户下次访问时，仍然可以保存上一次访问的界面风格。</li>
</ul>
<h3 id="articleHeader43">14.web worker</h3>
<p>在HTML页面中，如果在执行脚本时，页面的状态是不可相应的，直到脚本执行完成后，页面才变成可相应。web worker是运行在后台的js，独立于其他脚本，不会影响页面你的性能。并且通过postMessage将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。</p>
<p>如何创建web worker：</p>
<ul>
<li>检测浏览器对于web worker的支持性</li>
<li>创建web worker文件（js，回传函数等）</li>
<li>创建web worker对象</li>
</ul>
<h3 id="articleHeader44">15.对HTML语义化标签的理解</h3>
<p>HTML5语义化标签是指正确的标签包含了正确的内容，结构良好，便于阅读，比如nav表示导航条，类似的还有article、header、footer等等标签。</p>
<h3 id="articleHeader45">16.iframe是什么？有什么缺点？</h3>
<p>定义：iframe元素会创建包含另一个文档的内联框架<br>提示：可以将提示文字放在&lt;iframe&gt;&lt;/iframe&gt;之间，来提示某些不支持iframe的浏览器</p>
<p>缺点：</p>
<ul>
<li>会阻塞主页面的onload事件</li>
<li>搜索引擎无法解读这种页面，不利于SEO</li>
<li>iframe和主页面共享连接池，而浏览器对相同区域有限制所以会影响性能。</li>
</ul>
<h3 id="articleHeader46">17.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?</h3>
<p>Doctype声明于文档最前面，告诉浏览器以何种方式来渲染页面，这里有两种模式，严格模式和混杂模式。</p>
<ul>
<li>严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。</li>
<li>混杂模式，向后兼容，模拟老式浏览器，防止浏览器无法兼容页面。</li>
</ul>
<h3 id="articleHeader47">18.Cookie如何防范XSS攻击</h3>
<p>XSS（跨站脚本攻击）是指攻击者在返回的HTML中嵌入javascript脚本，为了减轻这些攻击，需要在HTTP头部配上，set-cookie：</p>
<ul>
<li>httponly-这个属性可以防止XSS,它会禁止javascript脚本来访问cookie。</li>
<li>secure - 这个属性告诉浏览器仅在请求为https的时候发送cookie。</li>
</ul>
<p>结果应该是这样的：Set-Cookie=&lt;cookie-value&gt;.....</p>
<h3 id="articleHeader48">19.Cookie和session的区别</h3>
<p>HTTP是一个无状态协议，因此Cookie的最大的作用就是存储sessionId用来唯一标识用户</p>
<h3 id="articleHeader49">20. 一句话概括RESTFUL</h3>
<p><strong><em>就是用URL定位资源，用HTTP描述操作</em></strong></p>
<h3 id="articleHeader50">21.讲讲viewport和移动端布局</h3>
<p>可以参考我的这篇文章：</p>
<p><a href="https://github.com/forthealllight/blog/issues/13" rel="nofollow noreferrer" target="_blank">响应式布局的常用解决方案对比(媒体查询、百分比、rem和vw/vh）</a></p>
<h3 id="articleHeader51">22. click在ios上有300ms延迟，原因及如何解决？</h3>
<h4>(1)粗暴型，禁用缩放</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" <meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no&quot;> 

" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs applescript"><code> &lt;meta <span class="hljs-built_in">name</span>=<span class="hljs-string">"viewport"</span> content=<span class="hljs-string">"width=device-width, user-scalable=no"</span>&gt; 

</code></pre>
<h4>(2)利用FastClick，其原理是：</h4>
<p>检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉</p>
<h2 id="articleHeader52">四、css篇</h2>
<h3 id="articleHeader53">1.css盒模型</h3>
<p>简介：就是用来装页面上的元素的矩形区域。CSS中的盒子模型包括IE盒子模型和标准的W3C盒子模型。</p>
<p>border-sizing(有3个值哦)：border-box,padding-box,content-box.</p>
<ul><li>标准盒子模型：</li></ul>
<p>&lt;img width="624" alt="2018-07-10 4 24 03" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648419a623a69db?w=1248&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=686&amp;f=png&amp;s=963248"&gt;</p>
<ul><li>IE盒子模型：</li></ul>
<p>&lt;img width="620" alt="2018-07-10 4 24 12" src="<a href="https://user-gold-cdn.xitu.io/2018/7/10/1648419a6d29fa5e?w=1240&amp;amp" rel="nofollow noreferrer" target="_blank">https://user-gold-cdn.xitu.io...</a>;h=656&amp;f=png&amp;s=1023920"&gt;</p>
<p>区别：从图中我们可以看出，这两种盒子模型最主要的区别就是width的包含范围，在标准的盒子模型中，width指content部分的宽度，在IE盒子模型中，width表示content+padding+border这三个部分的宽度，故这使得在计算整个盒子的宽度时存在着差异：</p>
<p>标准盒子模型的盒子宽度：左右border+左右padding+width<br>IE盒子模型的盒子宽度：width</p>
<p>在CSS3中引入了box-sizing属性，box-sizing:content-box;表示标准的盒子模型，box-sizing:border-box表示的是IE盒子模型</p>
<p>最后，前面我们还提到了，box-sizing:padding-box,这个属性值的宽度包含了左右padding+width</p>
<p>也很好理解性记忆，包含什么，width就从什么开始算起。</p>
<h3 id="articleHeader54">2.画一条0.5px的线</h3>
<ul>
<li>采用meta viewport的方式<p>&lt;meta name="viewport" content="initial-scale=1.0, maximum-scale=1.0, user-scalable=no" /&gt;</p>
</li>
<li>采用 border-image的方式</li>
<li>采用transform: scale()的方式</li>
</ul>
<h3 id="articleHeader55">3.link标签和import标签的区别</h3>
<ul>
<li>link属于html标签，而@import是css提供的</li>
<li>页面被加载时，link会同时被加载，而@import引用的css会等到页面加载结束后加载。</li>
<li>link是html标签，因此没有兼容性，而@import只有IE5以上才能识别。</li>
<li>link方式样式的权重高于@import的。</li>
</ul>
<h3 id="articleHeader56">4.transition和animation的区别</h3>
<p>Animation和transition大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是transition需要触发一个事件才能改变属性，而animation不需要触发任何事件的情况下才会随时间改变属性值，并且transition为2帧，从from .... to，而animation可以一帧一帧的。</p>
<h3 id="articleHeader57">5.Flex布局</h3>
<p>文章链接：<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html?utm_source=tuicool" rel="nofollow noreferrer" target="_blank">http://www.ruanyifeng.com/blo...</a>（语法篇）<br><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" rel="nofollow noreferrer" target="_blank">http://www.ruanyifeng.com/blo...</a>（实例篇）</p>
<p>Flex是Flexible Box的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。<br>布局的传统解决方案，基于盒状模型，依赖 display属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p>
<p>简单的分为容器属性和元素属性<br>容器的属性：</p>
<ul><li>flex-direction：决定主轴的方向（即子item的排列方法）</li></ul>
<p>.box {<br>  flex-direction: row | row-reverse | column | column-reverse;<br>}</p>
<ul><li>flex-wrap：决定换行规则</li></ul>
<p>.box{<br>  flex-wrap: nowrap | wrap | wrap-reverse;<br>}</p>
<ul><li>flex-flow：</li></ul>
<p>.box {<br>  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;<br>}</p>
<ul>
<li>justify-content：对其方式，水平主轴对齐方式</li>
<li>align-items：对齐方式，竖直轴线方向</li>
</ul>
<p>项目的属性（元素的属性）：</p>
<ul>
<li>order属性：定义项目的排列顺序，顺序越小，排列越靠前，默认为0</li>
<li>flex-grow属性：定义项目的放大比例，即使存在空间，也不会放大</li>
<li>flex-shrink属性：定义了项目的缩小比例，当空间不足的情况下会等比例的缩小，如果定义个item的flow-shrink为0，则为不缩小</li>
<li>flex-basis属性：定义了在分配多余的空间，项目占据的空间。</li>
<li>flex：是flex-grow和flex-shrink、flex-basis的简写，默认值为0 1 auto。</li>
<li>align-self：允许单个项目与其他项目不一样的对齐方式，可以覆盖align-items，默认属性为auto，表示继承父元素的align-items</li>
</ul>
<p>比如说，用flex实现圣杯布局</p>
<h3 id="articleHeader58">6.BFC（块级格式化上下文，用于清楚浮动，防止margin重叠等）</h3>
<p>直译成：块级格式化上下文，是一个独立的渲染区域，并且有一定的布局规则。</p>
<ul>
<li>BFC区域不会与float box重叠</li>
<li>BFC是页面上的一个独立容器，子元素不会影响到外面</li>
<li>计算BFC的高度时，浮动元素也会参与计算</li>
</ul>
<p>那些元素会生成BFC：</p>
<ul>
<li>根元素</li>
<li>float不为none的元素</li>
<li>position为fixed和absolute的元素</li>
<li>display为inline-block、table-cell、table-caption，flex，inline-flex的元素</li>
<li>overflow不为visible的元素</li>
</ul>
<h3 id="articleHeader59">7.垂直居中的方法</h3>
<h3 id="articleHeader60">(1)margin:auto法</h3>
<p>css:</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="div{
  width: 400px;
  height: 400px;
  position: relative;
  border: 1px solid #465468;
 }
 img{
      position: absolute;
      margin: auto;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
 }
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">div</span>{
  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#465468</span>;
 }
 <span class="hljs-selector-tag">img</span>{
      <span class="hljs-attribute">position</span>: absolute;
      <span class="hljs-attribute">margin</span>: auto;
      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;
      <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;
 }
</code></pre>
<p>html:</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="<div>
 <img src=&quot;mm.jpg&quot;>
</div>
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs xml"><code><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
 <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"mm.jpg"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>定位为上下左右为0，margin：0可以实现脱离文档流的居中.</p>
<h4>(2)margin负值法</h4>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=".container{
  width: 500px;
  height: 400px;
  border: 2px solid #379;
  position: relative;
}
.inner{
  width: 480px;
  height: 380px;
  background-color: #746;
  position: absolute;
  top: 50%;
  left: 50%;
  margin-top: -190px; /*height的一半*/
  margin-left: -240px; /*width的一半*/
 }
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-class">.container</span>{
  <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;
  <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#379</span>;
  <span class="hljs-attribute">position</span>: relative;
}
<span class="hljs-selector-class">.inner</span>{
  <span class="hljs-attribute">width</span>: <span class="hljs-number">480px</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">380px</span>;
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#746</span>;
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">190px</span>; <span class="hljs-comment">/*height的一半*/</span>
  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">240px</span>; <span class="hljs-comment">/*width的一半*/</span>
 }
</code></pre>
<p>补充：其实这里也可以将marin-top和margin-left负值替换成，<br>transform：translateX(-50%)和transform：translateY(-50%)</p>
<h4>(3)table-cell（未脱离文档流的）</h4>
<p>设置父元素的display:table-cell,并且vertical-align:middle，这样子元素可以实现垂直居中。</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="css:
div{
    width: 300px;
    height: 300px;
    border: 3px solid #555;
    display: table-cell;
    vertical-align: middle;
    text-align: center;
}
img{
    vertical-align: middle;
}
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">css</span>:
<span class="hljs-selector-tag">div</span>{
    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;
    <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#555</span>;
    <span class="hljs-attribute">display</span>: table-cell;
    <span class="hljs-attribute">vertical-align</span>: middle;
    <span class="hljs-attribute">text-align</span>: center;
}
<span class="hljs-selector-tag">img</span>{
    <span class="hljs-attribute">vertical-align</span>: middle;
}
</code></pre>
<h4>(4)利用flex</h4>
<p>将父元素设置为display:flex，并且设置align-items:center;justify-content:center;</p>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text="css:
.container{
      width: 300px;
      height: 200px;
      border: 3px solid #546461;
      display: -webkit-flex;
      display: flex;
      -webkit-align-items: center;
      align-items: center;
      -webkit-justify-content: center;
      justify-content: center;
 }
 .inner{
      border: 3px solid #458761;
      padding: 20px;
 }
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs css"><code><span class="hljs-selector-tag">css</span>:
<span class="hljs-selector-class">.container</span>{
      <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;
      <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;
      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#546461</span>;
      <span class="hljs-attribute">display</span>: -webkit-flex;
      <span class="hljs-attribute">display</span>: flex;
      <span class="hljs-attribute">-webkit-align-items</span>: center;
      <span class="hljs-attribute">align-items</span>: center;
      <span class="hljs-attribute">-webkit-justify-content</span>: center;
      <span class="hljs-attribute">justify-content</span>: center;
 }
 <span class="hljs-selector-class">.inner</span>{
      <span class="hljs-attribute">border</span>: <span class="hljs-number">3px</span> solid <span class="hljs-number">#458761</span>;
      <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;
 }
</code></pre>
<h3 id="articleHeader61">8.关于js动画和css3动画的差异性</h3>
<p>渲染线程分为main thread和compositor thread，如果css动画只改变transform和opacity，这时整个CSS动画得以在compositor trhead完成（而js动画则会在main thread执行，然后出发compositor thread进行下一步操作），特别注意的是如果改变transform和opacity是不会layout或者paint的。<br>区别：</p>
<ul>
<li>功能涵盖面，js比css大</li>
<li>实现/重构难度不一，CSS3比js更加简单，性能跳优方向固定</li>
<li>对帧速表现不好的低版本浏览器，css3可以做到自然降级</li>
<li>css动画有天然事件支持</li>
<li>css3有兼容性问题</li>
</ul>
<h3 id="articleHeader62">9.块元素和行元素</h3>
<p>块元素：独占一行，并且有自动填满父元素，可以设置margin和pading以及高度和宽度<br>行元素：不会独占一行，width和height会失效，并且在垂直方向的padding和margin会失<br>效。</p>
<h3 id="articleHeader63">10.多行元素的文本省略号</h3>
<div class="widget-codetool" style="display:none;">
      <div class="widget-codetool--inner">
      <span class="selectCode code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="全选"></span>
      <span type="button" class="copyCode code-tool" data-toggle="tooltip" data-placement="top" data-clipboard-text=" display: -webkit-box
-webkit-box-orient:vertical
-web-line-clamp:3
overflow:hidden
" title="" data-original-title="复制"></span>
      <span type="button" class="saveToNote code-tool" data-toggle="tooltip" data-placement="top" title="" data-original-title="放进笔记"></span>
      </div>
      </div><pre class="hljs haml"><code> display: -webkit-box
-<span class="ruby">webkit-box-<span class="hljs-symbol">orient:</span>vertical
</span>-<span class="ruby">web-line-<span class="hljs-symbol">clamp:</span><span class="hljs-number">3</span>
</span>overflow:hidden
</code></pre>
<h3 id="articleHeader64">11.visibility=hidden, opacity=0，display:none</h3>
<p>opacity=0，该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定一些事件，如click事件，那么点击该区域，也能触发点击事件的visibility=hidden，该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件display=none，把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删除掉一样。</p>
<h3 id="articleHeader65">12.双边距重叠问题（外边距折叠）</h3>
<p>多个相邻（兄弟或者父子关系）普通流的块元素垂直方向marigin会重叠</p>
<p>折叠的结果为：</p>
<p>两个相邻的外边距都是正数时，折叠结果是它们两者之间较大的值。<br>两个相邻的外边距都是负数时，折叠结果是两者绝对值的较大值。<br>两个外边距一正一负时，折叠结果是两者的相加的和。</p>

                
{{< /raw >}}

# 版权声明
本文仅用于学习、研究和交流目的。转载请注明出处、完整链接以及原作者。
本文资源来源互联网，仅供学习研究使用，版权归该资源的合法拥有者所有，
原作者若认为本站侵犯了您的版权，请联系我们，我们会立即删除！

## 原文链接
[https://segmentfault.com/a/1190000015591521](https://segmentfault.com/a/1190000015591521)

## 原文标题
总结了17年初到18年初百场前端面试的面试经验(含答案)
